# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Lower Triangular of the outer product
#'
#' @description
#' `lowerTriOuterProduct_cpp` calculates the outer product of \code{vec}
#' and returns the lower triangular part of the resulting matrix
#'
#' @param vec A numeric vector.
#'
lowerTriOuterProduct_cpp <- function(vec) {
    .Call(`_ellipsoidgaussian_lowerTriOuterProduct_cpp`, vec)
}

#' Gradient change due to log transformation
#'
#' @description
#' `logTransGradAdjust_cpp` calculates the gradient change due to log transformation.
#'
#' @param invSig A numeric vector, the parameter values.
#' @param invSig_jaco The associated Jacobian.
#'
logTransGradAdjust_cpp <- function(invSig, invSig_jaco) {
    .Call(`_ellipsoidgaussian_logTransGradAdjust_cpp`, invSig, invSig_jaco)
}

#' Gradient for the precision parameters
#'
#' @description
#' `calcPsdMat_lingSiv_jaco_cpp` calculates the Jacobian of the pseudo-normalising constant
#' w.r.t. \code{invSig} through change in the positive semi-definite matrix parameter.
#'
#' @param invSig A numeric vector, the precision parameters.
#' @param psdMat_grad The jacobian w.r.t. the positive semi-definite matrix.
#' @param lambda A numeric matrix of p by k, the factor loading matrix.
calcPsdMat_linvSig_jaco_cpp <- function(invSig, psdMat_grad, lambda) {
    .Call(`_ellipsoidgaussian_calcPsdMat_linvSig_jaco_cpp`, invSig, psdMat_grad, lambda)
}

#' Gradient for the precision parameters
#'
#' @description
#' `calcVec_linvSig_jaco_cpp` calculates the Jacobian of the pseudo-normalising constant
#' w.r.t. \code{invSig} through change in the vector paraemter.
#'
#' @param invSig A numeric vector the precision parameters.
#' @param vec_grad The gradient of the pseudo-normalising constant w.r.t. the vector.
#' @param lambda A numeric matrix, the factor loading matrix.
#' @param centered_sdat A numeric matrix, centered minibatch.
#'
calcVec_linvSig_jaco_cpp <- function(invSig, vec_grad, lambda, centered_sdat) {
    .Call(`_ellipsoidgaussian_calcVec_linvSig_jaco_cpp`, invSig, vec_grad, lambda, centered_sdat)
}

#' Gradient for the precision parameters
#'
#' @description
#' `calc_linvSig_grad_cpp` calculates the gradient of the log-likelihood w.r.t.
#' the function of the precisions that is being updated in the sampling procedure.
#'
#' @param invSig The precision parameters.
#' @param psdMat_grad The gradient w.r.t. the matrix parameter in the pseudo-normalising
#' constant.
#' @param vec_grad The gradient w.r.t. the vector parameter in the pseudo-normalising
#' constant.
#' @param lambda A numeric matrix, the factor loading matrix.
#' @param centered_sdat A numeric matrix, centered minibatch data.
#'
calc_linvSig_grad_cpp <- function(invSig, psdMat_grad, vec_grad, lambda, centered_sdat) {
    .Call(`_ellipsoidgaussian_calc_linvSig_grad_cpp`, invSig, psdMat_grad, vec_grad, lambda, centered_sdat)
}

#' Gradient for the factor loadings
#'
#' @description
#' `calc_lambda_grad_MatPart2_cpp` calculates the gradient of the log-likelihood through
#' the matrix parameter in the pseudo-normalising constant w.r.t. the factor loadings matrix.
#'
#' @param lambda A matrix, the factor loading.
#' @param psdMat_grad A matrix, the gradient w.r.t. the positive semi-definite matrix.
#' @param invSigma A vector, the precisions.
#'
calc_lambda_grad_MatPart2_cpp <- function(lambda, psdMat_grad, invSigma) {
    .Call(`_ellipsoidgaussian_calc_lambda_grad_MatPart2_cpp`, lambda, psdMat_grad, invSigma)
}

#' Gradient for the factor loadings
#'
#' @description
#' `calc_lambda_grad_VecPart_cpp` calculates the gradient of the log-likelihood
#' through the vector parameter in the pseudo-normalising constant w.r.t.
#' the factor loadings matrix.
#'
#' @param invSigma A numeric vector, the precisions.
#' @param centered_sdat A numeric matrix, centered minibatch.
#' @param vec_grad A vector, the gradient of the log-likelihiood
#' w.r.t. the vector parameter.
#'
calc_lambda_grad_VecPart_cpp <- function(invSigma, centered_sdat, vec_grad) {
    .Call(`_ellipsoidgaussian_calc_lambda_grad_VecPart_cpp`, invSigma, centered_sdat, vec_grad)
}

#' Gradient of the log-likelihood w.r.t. lambda
#'
#' @description
#' `calc_lambda_grad_cpp` calculates the gradient of the log-likelihood w.r.t.
#' lambda, where lambda is the factor loading matrix.
#'
#' @param lambda A numeric matrix, p by k, the factor loading matrix.
#' @param psdMat_grad The gradient w.r.t. the matrix parameter in the pseudo-normalising
#' constant.
#' @param vec_grad The gradient w.r.t. the vector parameter in the pseduo-normalising
#' constant.
#' @param invSigma A vector of precisions, length = p.
#' @param centered_sdat A matrix of centered minibatch data, n by p.
#'
calc_lambda_grad_cpp <- function(lambda, psdMat_grad, vec_grad, invSigma, centered_sdat) {
    .Call(`_ellipsoidgaussian_calc_lambda_grad_cpp`, lambda, psdMat_grad, vec_grad, invSigma, centered_sdat)
}

#' Matrix multiplication
#'
#' @description
#' `armaMatMult` calculates the matrix product of A and B.
#'
#' @param A a matrix
#' @param B a matrix
#'
armaMatMult <- function(A, B) {
    .Call(`_ellipsoidgaussian_armaMatMult`, A, B)
}

#' Matrix multiplication
#'
#' @description
#' `eigenMatMult` calculates the matrix product of A and B.
#'
#' @param A a matrix
#' @param B a matrix
#'
eigenMatMult <- function(A, B) {
    .Call(`_ellipsoidgaussian_eigenMatMult`, A, B)
}

#' Matrix multiplication
#'
#' @description
#' `eigeMapnMatMult` calculates the matrix product of A and B.
#'
#' @param A a matrix
#' @param B a matrix
#'
eigenMapMatMult <- function(A, B) {
    .Call(`_ellipsoidgaussian_eigenMapMatMult`, A, B)
}

#' Prior gradient of Lambda
#'
#' @description
#' `calcgradLambdaprior_cpp` calculates the gradient of the Dirichlet-Laplace
#' prior w.r.t. Lambda,  a factor loading matrix.
#'
#' @param Lambda A numeric matrix, the factor loading matrix.
#' @param phi A prior parameter in the Dirichlet-laplace prior.
#' @param kappa A prior parameter in the Dirichlet-Lapalce prior.
#'
calcgradLambdaprior_cpp <- function(Lambda, phi, kappa) {
    .Call(`_ellipsoidgaussian_calcgradLambdaprior_cpp`, Lambda, phi, kappa)
}

#' The rotation from a to b.
#'
#' @description
#' `rotate_cpp` finds the rotation matrix that transforms a to b.
#'
#' @param a A vector of length n.
#' @param b A vector of length n.
rotate_cpp <- function(a, b) {
    .Call(`_ellipsoidgaussian_rotate_cpp`, a, b)
}

#' Helper function for evaluating the pseudo-normalising constant
#'
#' @description
#' `kfb_cpp` is a helper function for evaluating the pseudo-normalising constant.
#' See \insertCite{KumeWood05}{ellipsoidgaussian} for more details.
#'
#' @references \insertAllCited{}
#'
#' @param j The power
#' @param gam Gamma.
#' @param lam Lambda.
#' @param ta t.
#'
kfb_cpp <- function(j, gam, lam, ta) {
    .Call(`_ellipsoidgaussian_kfb_cpp`, j, gam, lam, ta)
}

#' Find saddle point
#' @description
#' `saddle_equat_cpp` is a helper function for evaluating the pseudo-normalising constant.
#' See \insertCite{KumeWood05}{ellipsoidgaussian} for more details.
#'
#' @references \insertAllCited{}
#'
#' @param ta t.
#' @param gam Gamma.
#' @param lam Lambda.
#'
saddle_equat_cpp <- function(ta, gam, lam) {
    .Call(`_ellipsoidgaussian_saddle_equat_cpp`, ta, gam, lam)
}

#' Reorder vector
#'
#' @description
#' `reorder_vec` orders vector \code{v} based on the order \code{idx}.
#'
#' @param v A vector.
#' @param idx A vector of indices.
#'
reorder_vec <- function(v, idx) {
    .Call(`_ellipsoidgaussian_reorder_vec`, v, idx)
}

#' Find the root to the saddle point equation.
#'
#' @description
#' `root4SaddleEquat` finds the root to the saddlepoint equation
#'
#' @param gam A vector of length n.
#' @param lam A vector of length n.
#' @param low The lower bound of the solution.
#' @param up The upper bound of the solution.
#'
root4SaddleEquat <- function(gam, lam, low, up) {
    .Call(`_ellipsoidgaussian_root4SaddleEquat`, gam, lam, low, up)
}

#' Fisher-Bingham normalising constant
#'
#' @description
#' `findFBconst_cpp` calculates the normalising constant in the Fisher-Bingham
#' distribution.
#'
#' @param gam A vector
#' @param lam A vector
#' @param which_ The order of approximation. 1: First order; 2: second order first
#' type; 3: second order second type.
#' @param ordered Whether gam or lam is ordered.
#'
findFBconst_cpp <- function(gam, lam, which_, ordered) {
    .Call(`_ellipsoidgaussian_findFBconst_cpp`, gam, lam, which_, ordered)
}

#' Fisher-Bingham normalising constant
#'
#' @description
#' `approxFBconst_cpp` approximates the normalising constant in the Fisher-Bingham
#' distribution using saddlepoint approximation \insertCite{KumeWood05}{ellipsoidgaussian}.
#'
#' @param para1 The vector parameter, length is k.
#' @param para2 The matrix parameter, k by k.
#' @param idx_ The order of approximation,1: First order; 2: second order first
#' type; 3: second order second type.
#'
#' @references \insertAllCited{}
approxFBconst_cpp <- function(para1, para2, idx_) {
    .Call(`_ellipsoidgaussian_approxFBconst_cpp`, para1, para2, idx_)
}

#' Convert a vech format to a matrix
#'
#' @description
#' `Vech2Mat_cpp` converts a single vector of length \eqn{d(d+1)/2} obtained
#' through the vech (vector half) operation to its original matrix format. The vech
#' (vector half) operator takes a symmetric \eqn{d \times d} matrix and
#' stacks the lower triangular half into a single vector of length \eqn{d(d+1)/2}.
#'
#' @param para2_vech A vector obtained through vech operation.
#'
Vech2Mat_cpp <- function(para2_vech) {
    .Call(`_ellipsoidgaussian_Vech2Mat_cpp`, para2_vech)
}

#' Gradient w.r.t. the matrix parameter in the pseudo-normalising constant
#'
#' @description
#' `calclogPseudoconst_MatParGrad4_cpp` calculates the gradient of the logarithm
#' of the pseudo-normalising constant w.r.t. the matrix parameter.
#'
#' @param para2_vech A vector obtained through vech operation from the matrix
#' parameter.
#' @param para1 A vector, the vector parameter in the pseudo-normalising constant.
#'
calclogPseudoconst_MatParGrad4_cpp <- function(para2_vech, para1) {
    .Call(`_ellipsoidgaussian_calclogPseudoconst_MatParGrad4_cpp`, para2_vech, para1)
}

