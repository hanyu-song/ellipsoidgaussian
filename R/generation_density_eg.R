#' Density and random generation for the ellipsoid-Gaussian distribution
#'
#' @description
#' Density and random generation for the multivariate ellipsoid-Gaussian distribution
#' with parameters \code{center}, \code{Lambda}, \code{mu}, \code{tau} and \code{Sigma}.
#'
#' @details
#' An ellipsoid-Gaussian distribution with parameters \eqn{\mathbf{c}} (\code{center}), \eqn{\Lambda} (\code{Lambda}),
#' \eqn{\mu} (`mu`), \eqn{\tau} (`tau`) and \eqn{\Sigma} (`Sigma`)
#' has density
#' \deqn{f(\mathbf{x}) = \frac{C_k(\tau)}{(2\pi)^{\frac{p}{2}}\prod_{i = 1}^p \sigma_i}
#' \exp\left\{-\frac{1}{2} (x - {c})^T \Sigma^{-1} (x - {c})\right\}
#' \varsigma\left\{ \tau \mu + \Lambda^T \Sigma^{-1
#' }(x - {c}) , \frac{\Lambda^T \Sigma^{-1}\Lambda}{2}\right\},}
#' where \eqn{C_k(\tau) = ({\tau}/{2})^{k / 2 - 1}\{\Gamma(k / 2)I_{k /2 - 1}(\tau)\}^{-1}} and \eqn{I_{v}(\cdot)}
#' denotes the modified Bessel function of the first kind of order \eqn{v}, with respect to the Lebesgue measure on \eqn{\mathbb{R}^p,}
#' \eqn{\varsigma(\vartheta, A)} is the normalizing constant in a Fisher-Bingham distribution with density
#' \deqn{\frac{1}{\varsigma(\kappa \vartheta, A)} \exp\left(\kappa \vartheta^T{y} - {y}^T A {y}\right).} It is generated by
#' marginalizing over the distribution of \eqn{\eta} in a von-Mises Fisher linear factor model defined as follows:
#' \deqn{\mathbf{x} = \mathbf{c} + \Lambda \eta + \epsilon,\quad \epsilon \sim \text{N}_p({0}, \Sigma), \quad
#' \eta \sim \text{vMF}(\mu, \tau) \quad
#' \text{and} \quad  \Sigma = \text{diag}\left(\sigma_1^2, \ldots, \sigma_p^2\right).}
#'
#'
#' @param n Number of random vectors to be simulated.
#' @param center Vector of length \eqn{p}, representing the center of the underlying ellipsoid.
#' @param Lambda Matrix of dimension \eqn{p \times k}, representing the ellipsoid shape or the factor loading matrix.
#' in the von-Mises Fisher linear factor model.
#' @param mu Vector of length \eqn{k}.
#' @param tau The concentration parameter, non-negative.
#' @param Sigma Covariance matrix of the noise (\eqn{p \times p}), typically diagonal.
#'
#' @returns n samples from the ellipsoid-Gaussian distribution.
#' @export
#' @importFrom Rfast rvmf
#' @importFrom Rfast rmvnorm
#' @examples
#' dat <- rellipsoidgaussian(1000, rep(0,3), matrix(rnorm(6, mean = -5, sd = 2),nrow = 3, ncol = 2),
#' c(0,1), 1, diag(0.5,3))
rellipsoidgaussian <- function(n, center, Lambda, mu, tau, Sigma) {
  # generate data from ellipsoid-gaussian
  # model x = c + Lambda * eta + epsilon
  # where c is the center of the ellipsoid
  # Lambda is the p by k loading matrix
  # eta is sample from a von Mises-Fisher distribution with
  # parameters mu and tau
  # epsilon is multivariate normal with mean 0 and covariance Sigma
  # example:
  #      p <- 10
  #      k <- 3
  #      n <- 100
  #      c <- rnorm(p, -3,5)
  #      Lambda <- matrix(rnorm(p * k, -5, 3), nrow = p, ncol = k)
  #      mu <- rnorm(k, 0, 10)
  #      mu <- mu / norm(mu, type = '2)
  #      tau <- 5

  if (nrow(Lambda) != nrow(Sigma) || nrow(Sigma) != ncol(Sigma)) {
    stop('The dimension p is not well defined.')
  }
  p <- nrow(Lambda)
  Eta <- Rfast::rvmf(n, mu,tau)
  X <- matrix(NA, nrow = n, ncol = p)
  #noise <- mvtnorm::rmvnorm(n, mean = rep(0,p), sigma = Sigma)
  noise <- Rfast::rmvnorm(n, mu = rep(0,p), sigma = Sigma)
  for (i in seq_len(n)) {
    X[i,] <- center + Lambda %*% Eta[i,] + noise[i,]
  }
  return(X)
}
#' The logarithm of the normalizing constant in the von Mises-Fisher distribution
#'
#' @description
#' `calclogC_up2const` returns the logarithm of the normalising constant in
#' the von Mises-Fisher distribution up to a constant (i.e. excluding \eqn{(2 \pi)^{k / 2}}).
#'
#' @details
#' `calclogC_up2const` calculates the logarithm of the normalizing constant in
#' a von Mises-Fisher distribution up to a constant. The quantity is defined by
#' \deqn{ C_k(\tau) = \frac{\tau^{k / 2 - 1}}{ I_{k / 2 - 1}(\tau)}.}
#'
#' @param tau The concentration parameter (When on the original scale, tau > 0).
#' @param k The dimension.
#' @param logged Whether \eqn{\tau} is logged or not.
#' @returns The normalizing constant on the logarithm scale.
#' @export
#' @examples
#' calclogC_up2const(5, 3, TRUE)
calclogC_up2const <- function(tau, k, logged) {
  if (logged) {
    unlogged_tau <- exp(tau)
    res <- (k / 2 - 1) * log(unlogged_tau) - (log(besselI(unlogged_tau, k / 2 - 1, expon.scaled = T)) + unlogged_tau)
  }
  else {
    res <- (k / 2 - 1) * log(tau) - (log(besselI(tau, k / 2 - 1, expon.scaled = T)) + tau)
  }
  return(res)
}

#' Log density up to a constant
#'
#' @description
#' `calcMargDatallh_cpp2` calculates the log-likelihood under an ellipsoid-Gaussian
#' distribution up to a constant.
#'
#' @param dat Data in a matrix format (no. observations x no. dimensions p).
#' @param Sigma The noise variances, a vector of length p.
#' @param lambda The factor loading matrix, \eqn{p \times k}, where k is the number of latent dimensions.
#' @param tau The concentration parameter (> 0).
#' @param mu The mean direction parameter, a vector of length k.
#' @param center The ellipsoid center, a vector of length p.
#'
#' @returns The log-likelihood of the data up to constant.
#' @export
#' @examples
#' dellipsoidgaussian_up2const_logged(shell, rep(0.1,3), matrix(c(-0.5, -0.5, -0.7, -1.5, 1.3,
#'  0.1, 1.8, 2.2, -2.8),3,3),5, rep(1,3) / sqrt(3), rep(0,3))
dellipsoidgaussian_up2const_logged <- function(dat, Sigma, lambda, tau, mu, center) {
  centered_dat <- sweep(dat, MARGIN = 2, STATS = center, FUN = '-')
  n <- nrow(centered_dat)
  k <- ncol(lambda)
  const <- calclogC_up2const(tau, k,logged = F)
  const2 <- 0.5 * sum(log(Sigma))
  const <- const - const2
  const <- n * const
  centered_dat_sq <- centered_dat^2
  expon_part <- -0.5 * sum(sweep(centered_dat_sq, 2, Sigma, FUN = '/'))
  # Fisher-Bingham  "constant" term
  lambinvSig <- sweep(t(lambda),MARGIN = 2, STATS = Sigma, FUN = '/') # equivalent to  t(lambda) %*% diag(invSigma)
  para12 <- lambinvSig %*% t(centered_dat)
  para1 <- sweep(para12, 1, tau * mu, FUN = '+')
  para2 <- lambinvSig %*% lambda / 2
  fb_const_part <- sum(approxFBconst_cpp(para1, para2, idx_ = 3))
  res <- const + expon_part + fb_const_part
  return(res)
}



